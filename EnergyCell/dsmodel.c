#define DYNEventSpecial
/* DSblock model generated by Dymola from Modelica model EnergyCell.TestingExamples.Load_Test
 Dymola Version 2020x (64-bit), 2019-10-10 translated this at Sun Apr 12 17:46:18 2020

   */

#include <matrixop.h>
#if defined(DynSimStruct) || defined(BUILDFMU)
static double DymArrays1[3]={230.0, 50000000.0, 3.0};
static double DymArrays0[9]={50.0, 50.0, 25.0, 100.0, 2.0943951023932, 1.0, 3.0,
   314.1592653589793, 314.1592653589793};
#endif
/* Declaration of C-structs */
/* Prototypes for functions used in model */
/* Codes used in model */
/* DSblock C-code: */

#define NX_    7
#define NX2_   0
#define NU_    0
#define NY_    0
#define NW_    81
#define NP_    20
#define NPS_   0
#define ND_   0
#define NXP_   0
#define NInitial_   1
#define MAXAuxStr_   0
#define MAXAuxStrLen_   500
#define NHash1_ 256355116
#define NHash2_ 1200447499
#define NHash3_ 0
#define NI_    0
#define NRelF_ 0
#define NRel_  0
#define NTim_  0
#define NSamp_ 0
#define NCons_ 0
#define NA_    23
#define SizePre_ 0
#define SizeEq_ 3
#define SizeDelay_ 0
#define QNLmax_ 1
#define MAXAux 0
#define NrDymolaTimers_ 0
#define NWhen_ 0
#define NCheckIf_ 0
#define NGlobalHelp_ 104
#define NGlobalHelpI_ 31
#ifndef NExternalObject_
#define NExternalObject_ 0
#endif
#include <moutil.c>
DYMOLA_STATIC unsigned int FMIClockValueReferences_[1]={0};
DYMOLA_STATIC unsigned int FMIClockFirstValueReferences_[1]={0};
PreNonAliasDef(0)
PreNonAliasDef(1)
PreNonAliasDef(2)
PreNonAliasDef(3)
PreNonAliasDef(4)
PreNonAliasDef(5)
#if !defined(DYM2CCUR)
 DYMOLA_STATIC const char*modelName="EnergyCell.TestingExamples.Load_Test";
#endif
DYMOLA_STATIC const char*usedLibraries[]={0};
DYMOLA_STATIC const char*dllLibraryPath[]={0};
DYMOLA_STATIC const char*default_dymosim_license_filename=
 "c:/users/patri/appdata/roaming/dassaultsystemes/dymola/dymola.lic";
#define QJacobianCGDef_ 1
DYMOLA_STATIC int QJacobianCG_[15]={5 , 2 , 1 , 3 , 2 , 2 , 6 , 1 , 4 , 1 , 5 , 1
   , 7 , 0 , 0};
static int QJacobianGrp0[8]={1, 1, 3, 3, 3, 3, 3, 0};
static int QJacobianGrp1[8]={2, 2, 0, 6, 6, 6, 0, 0};
static int QJacobianGrp2[8]={4, 4, 4, 4, 0, 0, 0, 0};
static int QJacobianGrp3[8]={5, 5, 5, 5, 5, 5, 5, 0};
static int QJacobianGrp4[7]={1, 7 , 3 , 4 , 5 , 7 , 0};
DYMOLA_STATIC struct QJacobianTag_ QJacobianGC2_[6]={
{0, QJacobianGrp0},{0, QJacobianGrp1},{0, QJacobianGrp2},{0, QJacobianGrp3},{1, 
  QJacobianGrp4},{0,0}};
DYMOLA_STATIC double QJacobianCD_[8]={0  , 44 , 50 , 66 , 63 , 64 , 90 , 70};
#include <dsblock1.c>

/* Define variable names. */

#define Sections_

TranslatedEquations

InitialSection
#if defined(DynSimStruct) || defined(BUILDFMU)
DYNX(W_,0) = 1;
DYNX(W_,38) = 3;
DYNX(W_,40) = true;
DYNX(W_,55) = false;
memcpy(&DYNX(W_,1), &DymArrays0, sizeof(double)*9);
DYNX(W_,10) = true;
DYNX(W_,21) = 2;
DYNX(W_,30) = true;
DYNX(W_,31) = 1;
DYNX(W_,32) = 1;
DYNX(W_,35) = 1.0;
DYNX(W_,39) = 50.0;
DYNX(W_,51) = true;
memcpy(&DYNX(W_,52), &DymArrays1, sizeof(double)*3);
DYNX(W_,56) = 50000000.0;
DYNX(W_,57) = 0.001058;
DYNX(W_,64) = 52900.0;
DYNX(W_,67) = -115.00000000000092;
DYNX(W_,68) = 199.18584287042034;
DYNX(W_,46) = 0.0;
DYNX(W_,45) = 0.0;
DYNX(W_,33) = 0;
DYNX(W_,25) = 0.0;
DYNX(W_,47) = 314.1592653589793;
DYNX(W_,37) = 314.1592653589793;
DYNX(W_,59) = 0.0;
DYNX(W_,60) = 314.1592653589793;
DYNX(W_,44) = 0.0;
DYNX(W_,43) = 0.0;
DYNX(W_,13) = 314.1592653589793;
DYNX(W_,18) = 314.1592653589793;
DYNX(W_,14) = 0.0;
DYNX(W_,16) = 0.0;
DYNX(W_,15) = 0.0;
DYNX(W_,17) = 0.0;
DYNX(W_,12) = 0.0;
DYNX(W_,41) = 0.0;
DYNX(W_,29) = 0.0;
#endif
if (!DymolaUserHomotopy) UpdateInitVars(time, X_, XD_, U_, DP_, IP_, LP_, F_, Y_, W_, QZ_, duser_, iuser_, cuser_, did_, 1);
BoundParameterSection
DYNX(DYNhelp,0) = divinvGuarded(DYNX(DP_,1),"transPh.t_duration");
DYNX(W_,22) = DYNX(DYNhelp,0)*5.43656365691809;
DYNX(W_,58) = DYNX(DP_,10)*DYNX(W_,57);
DYNX(W_,63) = divGuarded(1+2*DYNX(DP_,11),"1+2*dynLoad.cpl",1-DYNX(DP_,11),
  "1-dynLoad.cpl");
DYNX(W_,65) = divGuarded(DYNX(W_,64)*DYNX(DP_,8),"dynLoad.V2_nom*dynLoad.pq0[1]",
  (DYNX(DP_,8)*DYNX(DP_,8)+DYNX(DP_,9)*DYNX(DP_,9))*DYNX(W_,56),"(dynLoad.pq0[1]*dynLoad.pq0[1]+dynLoad.pq0[2]*dynLoad.pq0[2])*dynLoad.S_base");
DYNX(W_,66) = divGuarded(DYNX(W_,64)*DYNX(DP_,9),"dynLoad.V2_nom*dynLoad.pq0[2]",
  (DYNX(DP_,8)*DYNX(DP_,8)+DYNX(DP_,9)*DYNX(DP_,9))*DYNX(W_,56),"(dynLoad.pq0[1]*dynLoad.pq0[1]+dynLoad.pq0[2]*dynLoad.pq0[2])*dynLoad.S_base");
DYNX(W_,69) = divGuarded(DYNX(W_,65)*DYNX(W_,67)+DYNX(W_,66)*DYNX(W_,68),
  "dynLoad.Z_start[1]*dynLoad.v_start[1]+dynLoad.Z_start[2]*dynLoad.v_start[2]",
  DYNX(W_,65)*DYNX(W_,65)+DYNX(W_,66)*DYNX(W_,66),"dynLoad.Z_start[1]*dynLoad.Z_start[1]+dynLoad.Z_start[2]*dynLoad.Z_start[2]");
DYNX(W_,70) = divGuarded(DYNX(W_,65)*DYNX(W_,68)-DYNX(W_,66)*DYNX(W_,67),
  "dynLoad.Z_start[1]*dynLoad.v_start[2]-dynLoad.Z_start[2]*dynLoad.v_start[1]",
  DYNX(W_,65)*DYNX(W_,65)+DYNX(W_,66)*DYNX(W_,66),"dynLoad.Z_start[1]*dynLoad.Z_start[1]+dynLoad.Z_start[2]*dynLoad.Z_start[2]");
BoundParameterConstantSection
DYNX(W_,62) = 50000000.0*DYNX(DP_,9);
DYNX(W_,61) = 50000000.0*DYNX(DP_,8);
BoundParameterSection
InitialSection
#if defined(DynSimStruct) || defined(BUILDFMU)
DYNX(W_,28) = 0.0;
DYNX(W_,36) = 0;
DYNX(W_,48) = 0.0;
DYNX(W_,49) = 0;
DYNX(W_,50) = 0;
#endif
InitialSection
InitialStartSection
InitialStartSection2
DYNX(W_,23) = DYNX(W_,67);
DYNX(W_,24) = DYNX(W_,68);
DYNX(W_,26) =  -DYNX(W_,69);
DYNX(W_,27) =  -DYNX(W_,70);
DYNX(W_,71) = DYNX(DP_,8);
DYNX(W_,72) = DYNX(DP_,9);
DYNX(X_,3) = DYNX(W_,65);
DYNX(X_,4) = DYNX(W_,66);
InitialSection
if (!DymolaUserHomotopy) UpdateInitVars(time, X_, XD_, U_, DP_, IP_, LP_, F_, Y_, W_, QZ_, duser_, iuser_, cuser_, did_, 1);
DefaultSection
InitializeData(0)
InitialSection
InitialSection2
DYNX(F_,3) = 0;
DYNX(F_,5) = 0;
DYNX(F_,4) = 0;
DYNX(F_,2) = 0.0;
DYNX(F_,6) = 0;
DYNX(F_,0) = 0.0;
DYNX(F_,1) = 0.0;
DYNX(W_,22) = divGuarded(5.43656365691809,"5.43656365691809",DYNX(DP_,1),
  "transPh.t_duration");
DYNX(W_,58) = DYNX(DP_,10)*DYNX(W_,57);
DYNX(W_,63) = divGuarded(1+2*DYNX(DP_,11),"1+2*dynLoad.cpl",1-DYNX(DP_,11),
  "1-dynLoad.cpl");
DYNX(W_,65) = divGuarded(DYNX(W_,64)*DYNX(DP_,8),"dynLoad.V2_nom*dynLoad.pq0[1]",
  (DYNX(DP_,8)*DYNX(DP_,8)+DYNX(DP_,9)*DYNX(DP_,9))*DYNX(W_,56),"(dynLoad.pq0[1]*dynLoad.pq0[1]+dynLoad.pq0[2]*dynLoad.pq0[2])*dynLoad.S_base");
DYNX(W_,66) = divGuarded(DYNX(W_,64)*DYNX(DP_,9),"dynLoad.V2_nom*dynLoad.pq0[2]",
  (DYNX(DP_,8)*DYNX(DP_,8)+DYNX(DP_,9)*DYNX(DP_,9))*DYNX(W_,56),"(dynLoad.pq0[1]*dynLoad.pq0[1]+dynLoad.pq0[2]*dynLoad.pq0[2])*dynLoad.S_base");
DYNX(W_,69) = divGuarded(DYNX(W_,65)*DYNX(W_,67)+DYNX(W_,66)*DYNX(W_,68),
  "dynLoad.Z_start[1]*dynLoad.v_start[1]+dynLoad.Z_start[2]*dynLoad.v_start[2]",
  DYNX(W_,65)*DYNX(W_,65)+DYNX(W_,66)*DYNX(W_,66),"dynLoad.Z_start[1]*dynLoad.Z_start[1]+dynLoad.Z_start[2]*dynLoad.Z_start[2]");
DYNX(W_,70) = divGuarded(DYNX(W_,65)*DYNX(W_,68)-DYNX(W_,66)*DYNX(W_,67),
  "dynLoad.Z_start[1]*dynLoad.v_start[2]-dynLoad.Z_start[2]*dynLoad.v_start[1]",
  DYNX(W_,65)*DYNX(W_,65)+DYNX(W_,66)*DYNX(W_,66),"dynLoad.Z_start[1]*dynLoad.Z_start[1]+dynLoad.Z_start[2]*dynLoad.Z_start[2]");
DYNX(W_,62) = 50000000.0*DYNX(DP_,9);
DYNX(W_,61) = 50000000.0*DYNX(DP_,8);
DYNX(W_,11) = DYNTime;
DYNX(W_,19) = 0.5*(DYNX(DP_,3)+DYNX(DP_,2)+tanh(DYNX(W_,22)*(DYNTime-DYNX(DP_,0)))
  *(DYNX(DP_,3)-DYNX(DP_,2)));
DYNX(W_,20) = 0.5*(DYNX(DP_,5)+DYNX(DP_,4)+tanh(DYNX(W_,22)*(DYNTime-DYNX(DP_,0)))
  *(DYNX(DP_,5)-DYNX(DP_,4)));
DYNX(W_,42) = 2.0943951023932+DYNX(W_,20);
DYNX(W_,23) = DYNX(W_,19)*cos(DYNX(W_,42));
DYNX(W_,24) = DYNX(W_,19)*sin(DYNX(W_,42));

{ /* Non-linear system of equations to solve. */
/* Tag: initialization.nonlinear[1] */
/* Introducing 21 common subexpressions used in 28 expressions */
/* Of the common subexpressions 21 are reals, 0 are integers, and 0
   are booleans. */
const char*const varnames_[]={"dynLoad.i_n"};
const double nominal_[]={1.0};
NonLinearSystemOfEquations(Jacobian__, residue__, x__, 1, 0, 0, 1, -2, 
  DYNX(DYNhelp,1), 35, DYNX(did_->helpvari_vec,0), 23);
SetInitVectorSimple(x__, 1, DYNX(W_,50), 0, 0);
Residues;
  DYNX(W_,49) = DYNX(W_,58)*DYNX(W_,50);
  DYNX(W_,48) = (-1.7320508075688772)*DYNX(W_,49);
  DYNX(W_,73) = DYNX(W_,23)*DYNX(W_,23)+DYNX(W_,24)*DYNX(W_,24)+DYNX(W_,48)*
    DYNX(W_,48);
  DYNX(W_,74) = 1.8903591682419658E-05*DYNX(W_,73);
  DYNX(DYNhelp,36) = 0.5*DYNX(DP_,14);
  DYNX(W_,76) = powGuarded(DYNX(W_,74),"dynLoad.v2_pu",DYNX(DYNhelp,36),
    "0.5*dynLoad.as[2]");
  DYNX(W_,78) = powGuarded(DYNX(W_,74),"dynLoad.v2_pu",0.5*DYNX(DP_,16),
    "0.5*dynLoad.at[2]");
  DYNX(W_,80) = (DYNX(W_,76)-DYNX(W_,78))*DYNX(W_,62);
  DYNX(W_,72) = DYNX(W_,78)*DYNX(W_,62)+DYNX(W_,80);
  DYNX(DYNhelp,37) = 0.5*DYNX(DP_,13);
  DYNX(W_,75) = powGuarded(DYNX(W_,74),"dynLoad.v2_pu",DYNX(DYNhelp,37),
    "0.5*dynLoad.as[1]");
  DYNX(W_,77) = powGuarded(DYNX(W_,74),"dynLoad.v2_pu",0.5*DYNX(DP_,15),
    "0.5*dynLoad.at[1]");
  DYNX(W_,79) = (DYNX(W_,75)-DYNX(W_,77))*DYNX(W_,61);
  DYNX(W_,71) = DYNX(W_,77)*DYNX(W_,61)+DYNX(W_,79);
  DYNX(W_,28) = (-0.5773502691896258)*DYNX(W_,50);
  DYNX(DYNhelp,38) = tanh(DYNX(DP_,12));
  DYNX(DYNhelp,39) = DYNX(DYNhelp,38)*DYNX(W_,73);
  DYNX(DYNhelp,40) = DYNX(DYNhelp,39)*DYNX(W_,71)*DYNX(DP_,19);
  DYNX(DYNhelp,41) = DYNX(W_,71)*DYNX(W_,71)+DYNX(W_,72)*DYNX(W_,72);
  DYNX(DYNhelp,42) = divinvGuarded(DYNX(DYNhelp,41),"dynLoad.pq_st[1]*dynLoad.pq_st[1]+dynLoad.pq_st[2]*dynLoad.pq_st[2]");
  DYNX(DYNhelp,43) = tanh(DYNX(DP_,12)*DYNX(W_,74));
  DYNX(DYNhelp,44) = divinvGuarded(DYNX(DYNhelp,43),"tanh(dynLoad.imax*dynLoad.v2_pu)");
  DYNX(DYNhelp,45) = divinvGuarded(DYNX(DP_,19),"dynLoad.tcst");
  DYNX(X_,3) = DYNX(DYNhelp,45)*DYNX(DYNhelp,44)*DYNX(DYNhelp,42)*
    DYNX(DYNhelp,40);
SetVector(residue__, 1, DYNX(X_,3)*DYNX(W_,28)+DYNX(W_,48));

Jacobian(Jacobian__)
MatrixZeros(Jacobian__);
DYNX(DYNhelp,46) = DYNX(DP_,19)*DYNX(DYNhelp,39);
DYNX(DYNhelp,47) = 2.0*DYNX(DYNhelp,40)*DYNX(W_,71);
DYNX(DYNhelp,48) = sqr(DYNX(DYNhelp,41));
DYNX(DYNhelp,49) = divinvGuarded(DYNX(DYNhelp,48),"(dynLoad.pq_st[1]*dynLoad.pq_st[1]+dynLoad.pq_st[2]*dynLoad.pq_st[2])^2");
DYNX(DYNhelp,50) = DYNX(DYNhelp,49)*DYNX(DYNhelp,47);
DYNX(DYNhelp,51) = 0.5*powGuarded(DYNX(W_,74),"dynLoad.v2_pu",DYNX(DYNhelp,37)-
  1.0,"0.5*dynLoad.as[1]-1.0")*DYNX(DP_,13)*DYNX(W_,61)*(DYNX(DYNhelp,42)*
  DYNX(DYNhelp,46)-DYNX(DYNhelp,50))*DYNX(W_,28);
DYNX(DYNhelp,52) = DYNX(DYNhelp,49)*powGuarded(DYNX(W_,74),"dynLoad.v2_pu",
  DYNX(DYNhelp,36)-1.0,"0.5*dynLoad.as[2]-1.0")*DYNX(DP_,14)*DYNX(W_,62)*
  DYNX(DYNhelp,40)*DYNX(W_,72)*DYNX(W_,28);
DYNX(DYNhelp,53) = DYNX(DYNhelp,40)*DYNX(DP_,12)*(1.0-DYNX(DYNhelp,43)*
  DYNX(DYNhelp,43))*DYNX(W_,28);
DYNX(DYNhelp,54) = sqr(DYNX(DYNhelp,43));
DYNX(DYNhelp,55) = DYNX(W_,71)*DYNX(DYNhelp,38);
DYNX(DYNhelp,56) = DYNX(W_,48)*(1.8903591682419658E-05*(DYNX(DYNhelp,44)*(
  DYNX(DYNhelp,51)-DYNX(DYNhelp,52))-divGuarded(DYNX(DYNhelp,42)*
  DYNX(DYNhelp,53),"tanh(dynLoad.imax)*dynLoad.v2*dynLoad.pq_st[1]*dynLoad.tcst*(dynLoad.imax*(1.0-tanh(dynLoad.imax*dynLoad.v2_pu)*tanh(dynLoad.imax*dynLoad.v2_pu)))*voltage.term.i[3]/(dynLoad.pq_st[1]*dynLoad.pq_st[1]+dynLoad.pq_st[2]*dynLoad.pq_st[2])",
  DYNX(DYNhelp,54),"tanh(dynLoad.imax*dynLoad.v2_pu)^2"))+DYNX(DYNhelp,44)*
  DYNX(DYNhelp,42)*DYNX(DP_,19)*DYNX(DYNhelp,55)*DYNX(W_,28));
SetMatrixLeading(Jacobian__, 1, 1, 1, (DYNX(DYNhelp,45)*(-3.4641016151377544)*
  DYNX(DYNhelp,56)-1.7320508075688772)*DYNX(W_,58)-0.5773502691896258*DYNX(X_,3));

SolveNonLinearSystemOfEquationsInit(Jacobian__, 0, 0, 0, residue__, x__,"Tag: initialization.nonlinear[1]");
DYNX(W_,50) = GetVector(x__, 1);
EndNonLinearSystemOfEquationsInit(residue__, x__, 1);
 /* End of Non-Linear Equation Block */ }



 /* Linear system of equations to solve. */
/* Introducing 1 common subexpressions used in 1 expressions */
/* Of the common subexpressions 1 are reals, 0 are integers, and 0
   are booleans. */
DYNX(DYNhelp,57) = divinvGuarded(DYNX(DP_,17),"dynLoad.t_rec[1]");
DYNX(X_,5) = 0.0;
SolveScalarLinearParametric( -DYNX(DYNhelp,57)," -1.0/dynLoad.t_rec[1]",  -
  DYNX(W_,79)," -dynLoad.xT[1]", DYNX(X_,5),"dynLoad.x[1]");
 /* End of Equation Block */ 

 /* Linear system of equations to solve. */
/* Introducing 3 common subexpressions used in 3 expressions */
/* Of the common subexpressions 3 are reals, 0 are integers, and 0
   are booleans. */
DYNX(DYNhelp,58) = divinvGuarded(DYNX(DP_,19),"dynLoad.tcst");
DYNX(DYNhelp,59) = DYNX(W_,71)*DYNX(W_,71)+DYNX(W_,72)*DYNX(W_,72);
DYNX(DYNhelp,60) = tanh(DYNX(DP_,12)*DYNX(W_,74));
DYNX(X_,4) = DYNX(W_,66);
SolveScalarLinearParametric( -DYNX(DYNhelp,58)*(-1.0)," -(-1.0)/dynLoad.tcst", 
  DYNX(DYNhelp,58)*divGuarded(divGuarded(tanh(DYNX(DP_,12))*DYNX(W_,73)*
  DYNX(W_,72),"tanh(dynLoad.imax)*dynLoad.v2*dynLoad.pq_st[2]",DYNX(DYNhelp,59),
  "dynLoad.pq_st[1]*dynLoad.pq_st[1]+dynLoad.pq_st[2]*dynLoad.pq_st[2]"),
  "tanh(dynLoad.imax)*dynLoad.v2*dynLoad.pq_st[2]/(dynLoad.pq_st[1]*dynLoad.pq_st[1]+dynLoad.pq_st[2]*dynLoad.pq_st[2])",
  DYNX(DYNhelp,60),"tanh(dynLoad.imax*dynLoad.v2_pu)"),"tanh(dynLoad.imax)*dynLoad.v2*dynLoad.pq_st[2]/(dynLoad.pq_st[1]*dynLoad.pq_st[1]+dynLoad.pq_st[2]*dynLoad.pq_st[2])/tanh(dynLoad.imax*dynLoad.v2_pu)/dynLoad.tcst",
   DYNX(X_,4),"dynLoad.Z[2]");
 /* End of Equation Block */ 

DYNX(X_,2) = (-0.0031830988618379067)*DYNX(X_,4)*DYNX(W_,63)*DYNX(W_,28);
 /* Linear system of equations to solve. */
/* Introducing 1 common subexpressions used in 1 expressions */
/* Of the common subexpressions 1 are reals, 0 are integers, and 0
   are booleans. */
DYNX(DYNhelp,61) = divinvGuarded(DYNX(DP_,18),"dynLoad.t_rec[2]");
DYNX(X_,6) = 0.0;
SolveScalarLinearParametric( -DYNX(DYNhelp,61)," -1.0/dynLoad.t_rec[2]",  -
  DYNX(W_,80)," -dynLoad.xT[2]", DYNX(X_,6),"dynLoad.x[2]");
 /* End of Equation Block */ 


 /* Linear system of equations to solve. */
/* Tag: initialization.linear[1] */
/* Introducing 1 common subexpressions used in 1 expressions */
/* Of the common subexpressions 1 are reals, 0 are integers, and 0
   are booleans. */
/* Automatic tearing of linear system of 4 simultaneous equations
gave a linear system of 2 equations for numerical solution.*/
{
  const char*const varnames_[]={"voltage.term.i[2]", "voltage.term.i[1]"};
  const double nominal_[]={1.0, 1.0};
  DidLinearSystemOfEquations(J, b, y, 2, DYNX(DYNhelp,62), 24, DYNX(did_->helpvari_vec,23), 8);
  /* Jacobian depending on continuous variables */
  SetNeedFactor(J);
  if (NeedFactor(J)) {
    MatrixZeros(J);
    DYNX(DYNhelp,86) =  -DYNX(X_,3);
    SetMatrixLeading(J, 1, 1, 2, DYNX(X_,4));
    SetMatrixLeading(J, 1, 2, 2, DYNX(DYNhelp,86));
    SetMatrixLeading(J, 2, 1, 2, DYNX(DYNhelp,86));
    SetMatrixLeading(J, 2, 2, 2, (-1.0)*DYNX(X_,4));
  }
  SetVector(b, 1, DYNX(W_,23));
  SetVector(b, 2, DYNX(W_,24));
  SetVector(y, 1,  -DYNX(W_,70));
  SetVector(y, 2,  -DYNX(W_,69));
  SolveLinearSystemOfEquations(J, b, y, 1, "initialization.linear[1]");
  DYNX(W_,27) = GetVector(y, 1);
  DYNX(W_,26) = GetVector(y, 2);
  EndStaticLinearSystemOfEquations(J);
}
DYNX(X_,0) = (-0.0031830988618379067)*DYNX(X_,4)*DYNX(W_,26);
DYNX(X_,1) = (-0.0031830988618379067)*DYNX(X_,4)*DYNX(W_,27);
 /* End of Equation Block */ 

InitialSection
InitialSectionB
Init_=false;InitializeData(2);Init_=true;
EndInitialSection

OutputSection

DynamicsSection
DYNX(DYNhelp,87) = tanh(DYNX(W_,22)*(DYNTime-DYNX(DP_,0)));
DYNX(W_,19) = 0.5*(DYNX(DP_,3)+DYNX(DP_,2)+DYNX(DYNhelp,87)*(DYNX(DP_,3)-
  DYNX(DP_,2)));
DYNX(W_,20) = 0.5*(DYNX(DP_,5)+DYNX(DP_,4)+DYNX(DYNhelp,87)*(DYNX(DP_,5)-
  DYNX(DP_,4)));
DYNX(W_,42) = 2.0943951023932+DYNX(W_,20);
DYNX(DYNhelp,88) = cos(DYNX(W_,42));
DYNX(W_,23) = DYNX(W_,19)*DYNX(DYNhelp,88);
DYNX(DYNhelp,89) = sin(DYNX(W_,42));
DYNX(W_,24) = DYNX(W_,19)*DYNX(DYNhelp,89);
 /* Linear system of equations to solve. */
DYNX(W_,28) = RememberSimple_(DYNX(W_,28), 0);
SolveScalarLinear(0.0031830988618379067*DYNX(X_,4)*DYNX(W_,63),"0.0031830988618379067*(dynLoad.Z[2]*dynLoad.c0)",
    -DYNX(X_,2)," -dynLoad.psi[3]", DYNX(W_,28),"voltage.term.i[3]");
 /* End of Equation Block */ 

DYNX(W_,50) = (-1.7320508075688772)*DYNX(W_,28);
DYNX(W_,49) = DYNX(W_,58)*DYNX(W_,50);
DYNX(W_,48) = (-1.7320508075688772)*DYNX(W_,49);
DYNX(W_,73) = DYNX(W_,23)*DYNX(W_,23)+DYNX(W_,24)*DYNX(W_,24)+DYNX(W_,48)*
  DYNX(W_,48);
DYNX(W_,74) = 1.8903591682419658E-05*DYNX(W_,73);
DYNX(W_,77) = powGuarded(DYNX(W_,74),"dynLoad.v2_pu",0.5*DYNX(DP_,15),
  "0.5*dynLoad.at[1]");
if (NewParameters_) {
DYNX(DYNhelp,90) = divinvGuarded(DYNX(DP_,17),"dynLoad.t_rec[1]");
}
DYNX(W_,79) = DYNX(DYNhelp,90)*DYNX(X_,5);
DYNX(W_,71) = DYNX(W_,77)*DYNX(W_,61)+DYNX(W_,79);
DYNX(W_,78) = powGuarded(DYNX(W_,74),"dynLoad.v2_pu",0.5*DYNX(DP_,16),
  "0.5*dynLoad.at[2]");
if (NewParameters_) {
DYNX(DYNhelp,91) = divinvGuarded(DYNX(DP_,18),"dynLoad.t_rec[2]");
}
DYNX(W_,80) = DYNX(DYNhelp,91)*DYNX(X_,6);
DYNX(W_,72) = DYNX(W_,78)*DYNX(W_,62)+DYNX(W_,80);
if (NewParameters_) {
DYNX(DYNhelp,92) = tanh(DYNX(DP_,12));
}
DYNX(DYNhelp,93) = DYNX(DYNhelp,92)*DYNX(W_,73);
DYNX(DYNhelp,94) = DYNX(W_,71)*DYNX(W_,71);
DYNX(DYNhelp,95) = DYNX(W_,72)*DYNX(W_,72);
DYNX(DYNhelp,96) = DYNX(DYNhelp,94)+DYNX(DYNhelp,95);
DYNX(DYNhelp,97) = tanh(DYNX(DP_,12)*DYNX(W_,74));
DYNX(DYNhelp,98) = divinvGuarded(DYNX(DYNhelp,97),"tanh(dynLoad.imax*dynLoad.v2_pu)");
if (NewParameters_) {
DYNX(DYNhelp,99) = divinvGuarded(DYNX(DP_,19),"dynLoad.tcst");
}
DYNX(F_,3) = DYNX(DYNhelp,99)*(DYNX(DYNhelp,98)*divGuarded(DYNX(DYNhelp,93)*
  DYNX(W_,71),"tanh(dynLoad.imax)*dynLoad.v2*dynLoad.pq_st[1]",DYNX(DYNhelp,96),
  "dynLoad.pq_st[1]*dynLoad.pq_st[1]+dynLoad.pq_st[2]*dynLoad.pq_st[2]")-
  DYNX(X_,3));
DYNX(W_,75) = powGuarded(DYNX(W_,74),"dynLoad.v2_pu",0.5*DYNX(DP_,13),
  "0.5*dynLoad.as[1]");
DYNX(F_,5) = (DYNX(W_,75)-DYNX(W_,77))*DYNX(W_,61)-DYNX(W_,79);
DYNX(DYNhelp,100) = DYNX(DYNhelp,92)*DYNX(W_,73);
DYNX(DYNhelp,101) = DYNX(W_,71)*DYNX(W_,71);
DYNX(DYNhelp,102) = DYNX(W_,72)*DYNX(W_,72);
DYNX(DYNhelp,103) = DYNX(DYNhelp,101)+DYNX(DYNhelp,102);
DYNX(F_,4) = DYNX(DYNhelp,99)*(DYNX(DYNhelp,98)*divGuarded(DYNX(DYNhelp,100)*
  DYNX(W_,72),"tanh(dynLoad.imax)*dynLoad.v2*dynLoad.pq_st[2]",DYNX(DYNhelp,103),
  "dynLoad.pq_st[1]*dynLoad.pq_st[1]+dynLoad.pq_st[2]*dynLoad.pq_st[2]")-
  DYNX(X_,4));
DYNX(F_,2) = DYNX(X_,3)*DYNX(W_,28)+DYNX(W_,48);
DYNX(W_,76) = powGuarded(DYNX(W_,74),"dynLoad.v2_pu",0.5*DYNX(DP_,14),
  "0.5*dynLoad.as[2]");
DYNX(F_,6) = (DYNX(W_,76)-DYNX(W_,78))*DYNX(W_,62)-DYNX(W_,80);
 /* Linear system of equations to solve. */
DYNX(W_,26) = RememberSimple_(DYNX(W_,26), 1);
SolveScalarLinear(0.0031830988618379067*DYNX(X_,4),"0.0031830988618379067*dynLoad.Z[2]",
    -DYNX(X_,0)," -dynLoad.psi[1]", DYNX(W_,26),"voltage.term.i[1]");
 /* End of Equation Block */ 

DYNX(F_,0) = DYNX(W_,23)+314.1592653589793*DYNX(X_,1)+DYNX(X_,3)*DYNX(W_,26);
 /* Linear system of equations to solve. */
DYNX(W_,27) = RememberSimple_(DYNX(W_,27), 2);
SolveScalarLinear(0.0031830988618379067*DYNX(X_,4),"0.0031830988618379067*dynLoad.Z[2]",
    -DYNX(X_,1)," -dynLoad.psi[2]", DYNX(W_,27),"voltage.term.i[2]");
 /* End of Equation Block */ 

DYNX(F_,1) = DYNX(W_,24)-314.1592653589793*DYNX(X_,0)+DYNX(X_,3)*DYNX(W_,27);

AcceptedSection1

AcceptedSection2
DYNX(W_,36) = 314.1592653589793*DYNTime;
DYNX(W_,34) = (-1.7320508075688772)*DYNX(W_,28);

DefaultSection
InitializeData(1)
EndTranslatedEquations

#include <dsblock6.c>

PreNonAliasNew(0)
StartNonAlias(0)
DeclareVariable("system.fType", "system frequency type [:#(type=PowerSystems.Types.SystemFrequency)]",\
 1, 1.0,3.0,0.0,0,517)
DeclareVariable("system.f", "frequency if type is parameter, else initial frequency [Hz]",\
 50, 0.0,0.0,0.0,0,513)
DeclareVariable("system.f_nom", "nominal frequency [Hz|Hz]", 50, 0.0,0.0,0.0,0,513)
DeclareVariable("system.f_lim[1]", "limit frequencies (for supervision of average frequency) [Hz]",\
 25.0, 0.0,0.0,0.0,0,513)
DeclareVariable("system.f_lim[2]", "limit frequencies (for supervision of average frequency) [Hz]",\
 100.0, 0.0,0.0,0.0,0,513)
DeclareVariable("system.alpha0", "phase angle [rad|deg]", 2.0943951023932, \
0.0,0.0,0.0,0,513)
DeclareVariable("system.refType", "reference frame (3-phase) [:#(type=PowerSystems.Types.ReferenceFrame)]",\
 1, 1.0,2.0,0.0,0,517)
DeclareVariable("system.dynType", "transient or steady-state model [:#(type=PowerSystems.Types.Dynamics)]",\
 3, 1.0,4.0,0.0,0,517)
DeclareVariable("system.omega_nom", "nominal angular frequency [rad/s]", \
314.1592653589793, 0.0,0.0,0.0,0,513)
DeclareVariable("system.w_nom", "nom r.p.m. [rad/s|rpm]", 314.1592653589793, \
0.0,0.0,0.0,0,513)
DeclareVariable("system.synRef", "[:#(type=Boolean)]", true, 0.0,0.0,0.0,0,515)
DeclareVariable("system.initime", "[s]", 0.0, 0.0,0.0,0.0,0,513)
DeclareAlias2("system.theta", "system angle [rad|deg]", "voltage.theta", 1, 5, 36,\
 0)
DeclareVariable("system.thetaRel", "angle relative to reference frame [rad|deg]",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareAlias2("system.thetaRef", "angle of reference frame [rad|deg]", \
"voltage.theta", 1, 5, 36, 0)
DeclareVariable("system.omega", "[rad/s]", 314.1592653589793, 0.0,0.0,0.0,0,513)
DeclareVariable("system.receiveFreq.H", "inertia constant [s]", 0.0, 0.0,0.0,0.0,\
0,777)
DeclareVariable("system.receiveFreq.w_H", "angular velocity, inertia-weighted [rad|deg]",\
 0.0, 0.0,0.0,0.0,0,777)
DeclareVariable("system.receiveFreq.h", "Dummy potential-variable to balance flow-variable H",\
 0.0, 0.0,0.0,0.0,0,521)
DeclareVariable("system.receiveFreq.w_h", "Dummy potential-variable to balance flow-variable w_H",\
 0.0, 0.0,0.0,0.0,0,521)
DeclareVariable("system.omega_internal", "[rad/s]", 314.1592653589793, 0.0,0.0,\
0.0,0,2561)
DeclareVariable("transPh.y[1]", "output signal-vector [rad]", 0.0, 0.0,0.0,\
1000.0,0,512)
DeclareVariable("transPh.y[2]", "output signal-vector [rad]", 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("transPh.n", "dim of output signal-vector [:#(type=Integer)]", 2,\
 0.0,0.0,0.0,0,517)
DeclareParameter("transPh.t_change", "time when change [s]", 0, 0.5, 0.0,0.0,0.0,\
0,560)
DeclareParameter("transPh.t_duration", "transition duration [s]", 1, 1, 0.0,0.0,\
0.0,0,560)
DeclareParameter("transPh.a_start", "initial norm |y|", 2, 1, 0.0,0.0,0.0,0,560)
DeclareParameter("transPh.a_end", "final norm |y|", 3, 1, 0.0,0.0,0.0,0,560)
DeclareParameter("transPh.ph_start", "initial phase (y) [rad|deg]", 4, 0, \
0.0,0.0,0.0,0,560)
DeclareParameter("transPh.ph_end", "final phase (y) [rad|deg]", 5, 0, 0.0,0.0,\
0.0,0,560)
DeclareVariable("transPh.coef", "[Hz]", 0.0, 0.0,0.0,0.0,0,2561)
DeclareVariable("voltage.term.v[1]", "voltage vector [V|kV]", 0.0, 0.0,0.0,\
1000.0,0,520)
DeclareVariable("voltage.term.v[2]", "voltage vector [V|kV]", 0.0, 0.0,0.0,\
1000.0,0,520)
DeclareVariable("voltage.term.v[3]", "voltage vector [V|kV]", 0.0, 0.0,0.0,\
1000.0,0,521)
DeclareVariable("voltage.term.i[1]", "current vector [A]", 0.0, 0.0,0.0,1.0,0,776)
DeclareVariable("voltage.term.i[2]", "current vector [A]", 0.0, 0.0,0.0,1.0,0,776)
DeclareVariable("voltage.term.i[3]", "current vector [A]", 0.0, 0.0,0.0,1.0,0,776)
DeclareVariable("voltage.term.theta[1]", "optional vector of phase angles [rad|deg]",\
 0.0, 0.0,0.0,0.0,0,521)
DeclareAlias2("voltage.term.theta[2]", "optional vector of phase angles [rad|deg]",\
 "voltage.theta", 1, 5, 36, 4)
DeclareVariable("voltage.puUnits", "= true, if scaled with nom. values (pu), else scaled with 1 (SI) [:#(type=Boolean)]",\
 true, 0.0,0.0,0.0,0,515)
DeclareVariable("voltage.V_nom", "nominal Voltage (= base for pu) [V|kV]", 1, \
0.0,1E+100,0.0,0,513)
DeclareVariable("voltage.S_nom", "nominal Power (= base for pu) [VA|MVA]", 1, \
0.0,1E+100,0.0,0,513)
DeclareVariable("voltage.neutral.v", "Potential at the pin [V]", 0, 0.0,0.0,0.0,\
0,521)
DeclareVariable("voltage.neutral.i", "Current flowing into the pin [A]", 0.0, \
0.0,0.0,0.0,0,776)
DeclareVariable("voltage.V_base", "[V|kV]", 1.0, 0.0,0.0,1000.0,0,2561)
DeclareVariable("voltage.theta", "absolute angle [rad|deg]", 0, 0.0,0.0,0.0,0,2560)
DeclareVariable("voltage.der(theta)", "der(absolute angle) [rad/s]", \
314.1592653589793, 0.0,0.0,0.0,0,2561)
DeclareVariable("voltage.fType", "frequency type [:#(type=PowerSystems.Types.SourceFrequency)]",\
 3, 1.0,3.0,0.0,0,517)
DeclareVariable("voltage.f", "frequency if type is parameter [Hz]", 50.0, \
0.0,0.0,0.0,0,513)
DeclareVariable("voltage.use_vPhasor_in", "= true to use input signal vPhasor_in, otherwise use fixed values [:#(type=Boolean)]",\
 true, 0.0,0.0,0.0,0,515)
DeclareAlias2("voltage.vPhasor_in[1]", "{abs(voltage), phase} [rad]", \
"transPh.y[1]", 1, 5, 19, 0)
DeclareAlias2("voltage.vPhasor_in[2]", "{abs(voltage), phase} [rad]", \
"transPh.y[2]", 1, 5, 20, 0)
DeclareVariable("voltage.omega_internal", "Needed to connect to conditional connector [rad/s]",\
 0.0, 0.0,0.0,0.0,0,2561)
DeclareAlias2("voltage.vPhasor_internal[1]", "Needed to connect to conditional connector [rad]",\
 "transPh.y[1]", 1, 5, 19, 1024)
DeclareAlias2("voltage.vPhasor_internal[2]", "Needed to connect to conditional connector [rad]",\
 "transPh.y[2]", 1, 5, 20, 1024)
DeclareParameter("voltage.v0", "fixed voltage [V/V]", 6, 1, 0.0,0.0,0.0,0,560)
DeclareParameter("voltage.alpha0", "fixed phase angle [rad|deg]", 7, 0, 0.0,0.0,\
0.0,0,560)
DeclareAlias2("voltage.V", "[V|kV]", "transPh.y[1]", 1, 5, 19, 1024)
DeclareAlias2("voltage.alpha", "[rad|deg]", "transPh.y[2]", 1, 5, 20, 1024)
DeclareVariable("voltage.phi", "[rad|deg]", 0.0, 0.0,0.0,0.0,0,2560)
DeclareVariable("grd.term.v", "Potential at the pin [V]", 0.0, 0.0,0.0,0.0,0,521)
DeclareAlias2("grd.term.i", "Current flowing into the pin [A]", "voltage.neutral.i", -1,\
 5, 34, 132)
DeclareAlias2("dynLoad.term.v[1]", "voltage vector [V|kV]", "voltage.term.v[1]", 1,\
 5, 23, 4)
DeclareAlias2("dynLoad.term.v[2]", "voltage vector [V|kV]", "voltage.term.v[2]", 1,\
 5, 24, 4)
DeclareVariable("dynLoad.term.v[3]", "voltage vector [V|kV]", 0.0, 0.0,0.0,\
1000.0,0,521)
DeclareAlias2("dynLoad.term.i[1]", "current vector [A]", "voltage.term.i[1]", -1,\
 5, 26, 132)
DeclareAlias2("dynLoad.term.i[2]", "current vector [A]", "voltage.term.i[2]", -1,\
 5, 27, 132)
DeclareAlias2("dynLoad.term.i[3]", "current vector [A]", "voltage.term.i[3]", -1,\
 5, 28, 132)
DeclareVariable("dynLoad.term.theta[1]", "optional vector of phase angles [rad|deg]",\
 0.0, 0.0,0.0,0.0,0,521)
DeclareAlias2("dynLoad.term.theta[2]", "optional vector of phase angles [rad|deg]",\
 "voltage.theta", 1, 5, 36, 4)
DeclareVariable("dynLoad.term.der(theta[1])", "der(optional vector of phase angles) [rad/s]",\
 0.0, 0.0,0.0,0.0,0,521)
DeclareVariable("dynLoad.term.der(theta[2])", "der(optional vector of phase angles) [rad/s]",\
 314.1592653589793, 0.0,0.0,0.0,0,521)
DeclareAlias2("dynLoad.v[1]", "voltage terminal to neutral [V|kV]", \
"voltage.term.v[1]", 1, 5, 23, 0)
DeclareAlias2("dynLoad.v[2]", "voltage terminal to neutral [V|kV]", \
"voltage.term.v[2]", 1, 5, 24, 0)
DeclareVariable("dynLoad.v[3]", "voltage terminal to neutral [V|kV]", 0.0, \
0.0,0.0,1000.0,0,512)
DeclareAlias2("dynLoad.i[1]", "current terminal in [A]", "voltage.term.i[1]", -1,\
 5, 26, 0)
DeclareAlias2("dynLoad.i[2]", "current terminal in [A]", "voltage.term.i[2]", -1,\
 5, 27, 0)
DeclareAlias2("dynLoad.i[3]", "current terminal in [A]", "voltage.term.i[3]", -1,\
 5, 28, 0)
DeclareVariable("dynLoad.v_n", "voltage neutral [V|kV]", 0, 0.0,0.0,1000.0,0,512)
DeclareVariable("dynLoad.i_n", "current neutral [A]", 0, 0.0,0.0,1.0,0,576)
DeclareVariable("dynLoad.puUnits", "= true, if scaled with nom. values (pu), else scaled with 1 (SI) [:#(type=Boolean)]",\
 true, 0.0,0.0,0.0,0,515)
DeclareVariable("dynLoad.V_nom", "nominal Voltage (= base for pu) [V|V]", 230, \
0.0,1E+100,0.0,0,513)
DeclareVariable("dynLoad.S_nom", "nominal Power (= base for pu) [VA|MVA]", 50000000,\
 0.0,1E+100,0.0,0,513)
DeclareVariable("dynLoad.dynType", "transient or steady-state model [:#(type=PowerSystems.Types.Dynamics)]",\
 3, 1.0,4.0,0.0,0,517)
DeclareVariable("dynLoad.use_pq_in", "= true to use input signal pq_in, otherwise use parameter pq0 [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,515)
DeclareParameter("dynLoad.pq0[1]", "fixed {active, reactive} power (start value if use_pq_in) [W/W]",\
 8, 0.8660254037844386, 0.0,1E+100,0.0,0,560)
DeclareParameter("dynLoad.pq0[2]", "fixed {active, reactive} power (start value if use_pq_in) [W/W]",\
 9, 0.5, 0.0,1E+100,0.0,0,560)
DeclareParameter("dynLoad.r_n", "resistance neutral to grd [Ohm/(V.V/VA)]", 10, 0,\
 0.0,1E+100,0.0,0,560)
DeclareVariable("dynLoad.S_base", "[VA]", 50000000.0, 0.0,0.0,0.0,0,2561)
DeclareVariable("dynLoad.R_base", "[Ohm]", 0.001058, 0.0,0.0,0.0,0,2561)
DeclareVariable("dynLoad.R_n", "[Ohm]", 0.0, 0.0,0.0,0.0,0,2561)
DeclareVariable("dynLoad.omega[1]", "[rad/s]", 0.0, 0.0,0.0,0.0,0,2561)
DeclareVariable("dynLoad.omega[2]", "[rad/s]", 314.1592653589793, 0.0,0.0,0.0,0,2561)
DeclareVariable("dynLoad.pq[1]", "[W|MW]", 0.0, 0.0,0.0,0.0,0,2561)
DeclareVariable("dynLoad.pq[2]", "[W|MW]", 0.0, 0.0,0.0,0.0,0,2561)
DeclareAlias2("dynLoad.pq_internal[1]", "Needed to connect to conditional connector [1]",\
 "dynLoad.pq0[1]", 1, 7, 8, 1024)
DeclareAlias2("dynLoad.pq_internal[2]", "Needed to connect to conditional connector [1]",\
 "dynLoad.pq0[2]", 1, 7, 9, 1024)
DeclareParameter("dynLoad.cpl", "phase coupling x_m/x_s, (-1/2 < cpl < 1)", 11, 0,\
 -0.5,1.0,0.0,0,560)
DeclareState("dynLoad.psi[1]", "magnetic flux [Wb]", 0, 0.0, 0.0,0.0,0.0,0,544)
DeclareDerivative("dynLoad.der(psi[1])", "der(magnetic flux) [V]", 0.0, 0.0,0.0,\
0.0,0,512)
DeclareState("dynLoad.psi[2]", "magnetic flux [Wb]", 1, 0.0, 0.0,0.0,0.0,0,544)
DeclareDerivative("dynLoad.der(psi[2])", "der(magnetic flux) [V]", 0.0, 0.0,0.0,\
0.0,0,512)
DeclareState("dynLoad.psi[3]", "magnetic flux [Wb]", 2, 0.0, 0.0,0.0,0.0,0,544)
DeclareDerivative("dynLoad.der(psi[3])", "der(magnetic flux) [V]", 0.0, 0.0,0.0,\
0.0,0,512)
DeclareVariable("dynLoad.c0", "", 0.0, 0.0,0.0,0.0,0,2561)
DeclareVariable("dynLoad.V2_nom", "[m4.kg2.s-6.A-2]", 52900.0, 0.0,0.0,0.0,0,2561)
DeclareVariable("dynLoad.Z_start[1]", "[Ohm]", 0.0, 0.0,0.0,0.0,0,2561)
DeclareVariable("dynLoad.Z_start[2]", "[Ohm]", 0.0, 0.0,0.0,0.0,0,2561)
DeclareVariable("dynLoad.v_start[1]", "[V|kV]", -115.00000000000092, 0.0,0.0,\
1000.0,0,2561)
DeclareVariable("dynLoad.v_start[2]", "[V|kV]", 199.18584287042034, 0.0,0.0,\
1000.0,0,2561)
DeclareVariable("dynLoad.i_start[1]", "[A]", 0.0, 0.0,0.0,1.0,0,2561)
DeclareVariable("dynLoad.i_start[2]", "[A]", 0.0, 0.0,0.0,1.0,0,2561)
DeclareState("dynLoad.Z[1]", "[Ohm]", 3, 0.0, 0.0,0.0,0.0,0,2592)
DeclareDerivative("dynLoad.der(Z[1])", "[Ohm/s]", 0.0, 0.0,0.0,0.0,0,2560)
DeclareState("dynLoad.Z[2]", "[Ohm]", 4, 0.0, 0.0,0.0,0.0,0,2592)
DeclareDerivative("dynLoad.der(Z[2])", "[Ohm/s]", 0.0, 0.0,0.0,0.0,0,2560)
DeclareParameter("dynLoad.imax", "maximum current [1]", 12, 2, 0.0,0.0,0.0,0,560)
DeclareParameter("dynLoad.as[1]", "voltage exponent steady-state power", 13, 0.5,\
 0.0,0.0,0.0,0,560)
DeclareParameter("dynLoad.as[2]", "voltage exponent steady-state power", 14, 1.0,\
 0.0,0.0,0.0,0,560)
DeclareParameter("dynLoad.at[1]", "voltage exponent transient power", 15, 2, \
0.0,0.0,0.0,0,560)
DeclareParameter("dynLoad.at[2]", "voltage exponent transient power", 16, 2, \
0.0,0.0,0.0,0,560)
DeclareParameter("dynLoad.t_rec[1]", "power recovery times [s]", 17, 60, \
0.0,0.0,0.0,0,560)
DeclareParameter("dynLoad.t_rec[2]", "power recovery times [s]", 18, 60, \
0.0,0.0,0.0,0,560)
DeclareParameter("dynLoad.tcst", "time constant Z [s]", 19, 0.01, 0.0,0.0,0.0,0,560)
DeclareVariable("dynLoad.pq_st[1]", "[W|MW]", 0.0, 0.0,0.0,0.0,0,2560)
DeclareVariable("dynLoad.pq_st[2]", "[W|MW]", 0.0, 0.0,0.0,0.0,0,2560)
DeclareVariable("dynLoad.v2", "[m4.kg2.s-6.A-2]", 0.0, 0.0,0.0,0.0,0,2560)
DeclareVariable("dynLoad.v2_pu", "[1]", 0.0, 0.0,0.0,0.0,0,2560)
DeclareState("dynLoad.x[1]", "[J]", 5, 0.0, 0.0,0.0,0.0,0,2592)
DeclareDerivative("dynLoad.der(x[1])", "[W]", 0.0, 0.0,0.0,0.0,0,2560)
DeclareState("dynLoad.x[2]", "[J]", 6, 0.0, 0.0,0.0,0.0,0,2592)
DeclareDerivative("dynLoad.der(x[2])", "[W]", 0.0, 0.0,0.0,0.0,0,2560)
DeclareVariable("dynLoad.vs[1]", "", 0.0, 0.0,0.0,0.0,0,2560)
DeclareVariable("dynLoad.vs[2]", "", 0.0, 0.0,0.0,0.0,0,2560)
DeclareVariable("dynLoad.vt[1]", "", 0.0, 0.0,0.0,0.0,0,2560)
DeclareVariable("dynLoad.vt[2]", "", 0.0, 0.0,0.0,0.0,0,2560)
DeclareVariable("dynLoad.xT[1]", "[W]", 0.0, 0.0,0.0,0.0,0,2560)
DeclareVariable("dynLoad.xT[2]", "[W]", 0.0, 0.0,0.0,0.0,0,2560)
EndNonAlias(0)

#define DymolaHaveUpdateInitVars 1
#include <dsblock5.c>

DYMOLA_STATIC void UpdateInitVars(double*time, double* X_, double* XD_, double* U_, double* DP_, int IP_[], Dymola_bool LP_[], double* F_, double* Y_, double* W_, double QZ_[], double duser_[], int iuser_[], void*cuser_[],struct DYNInstanceData*did_,int initialCall) {
if (initialCall) DYNX(did_->xInitial_var, 0)=DYNX(W_,50);
else if (DYNHReject) DYNX(W_,50)=did_->xInitial_var2[0]; else did_->xInitial_var2[0]=
  DYNX(W_,50);
}
StartDataBlock
StartEqBlock
DoRemember_(DYNX(W_,26),  -DYNX(W_,69), 1);
DoRemember_(DYNX(W_,27),  -DYNX(W_,70), 2);
DoRemember_(DYNX(W_,28), 0.0, 0);
EndEqBlock
EndDataBlock
